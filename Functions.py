import numpy as np
from sympy import *

def StiffnessTensorGenerator():
    A = np.empty(shape=[3, 3, 3, 3])
    A[0][0][0][0] = int(input('A_1111 = ') or '0')  # 1
    A[0][0][1][1] = A[1][1][0][0] = int(input('A_1122 = ') or '0')  # 2
    A[0][0][2][2] = A[2][2][0][0] = int(input('A_1133 = ') or '0')  # 2
    A[0][0][1][2] = A[2][1][0][0] = A[1][2][0][0] = A[0][0][2][1] = int(input('A_1123 = ') or '0')  # 4
    A[0][0][0][2] = A[0][2][0][0] = A[0][0][2][0] = A[2][0][0][0] = int(input('A_1113 = ') or '0')  # 4
    A[0][0][0][1] = A[0][0][1][0] = A[0][1][0][0] = A[1][0][0][0] = int(input('A_1112 = ') or '0')  # 4
    A[1][1][1][1] = int(input('A_2222 = ') or '0')  # 1
    A[1][1][2][2] = A[2][2][1][1] = int(input('A_2233 = ') or '0')  # 2
    A[1][1][1][2] = A[2][1][1][1] = A[1][2][1][1] = A[1][1][2][1] = int(input('A_2223 = ') or '0')  # 4
    A[1][1][0][2] = A[2][0][1][1] = A[0][2][1][1] = A[1][1][2][0] = int(input('A_2213 = ') or '0')  # 4
    A[1][1][0][1] = A[1][0][1][1] = A[0][1][1][1] = A[1][1][1][0] = int(input('A_2212 = ') or '0')  # 4
    A[2][2][2][2] = int(input('A_3333 = ') or '0')  # 1
    A[2][2][1][2] = A[2][1][2][2] = A[2][2][2][1] = A[1][2][2][2] = int(input('A_3323 = ') or '0')  # 4
    A[2][2][0][2] = A[2][0][2][2] = A[0][2][2][2] = A[2][2][2][0] = int(input('A_3313 = ') or '0')  # 4
    A[2][2][0][1] = A[1][0][2][2] = A[2][2][1][0] = A[0][1][2][2] = int(input('A_3312 = ') or '0')  # 4
    A[1][2][1][2] = A[2][1][1][2] = A[1][2][2][1] = A[2][1][2][1] = int(input('A_2323 = ') or '0')  # 4
    A[1][2][0][2] = A[2][1][2][0] = A[2][0][1][2] = A[2][1][0][2] = A[0][2][1][2] = A[0][2][2][1] = A[1][2][2][0] = \
    A[2][0][2][1] = int(input('A_2313 = ') or '0')  # 8
    A[1][2][0][1] = A[2][1][1][0] = A[1][0][1][2] = A[2][1][0][1] = A[0][1][1][2] = A[0][1][2][1] = A[1][2][1][0] = \
    A[1][0][2][1] = int(input('A_2312 = ') or '0')  # 8
    A[0][2][0][2] = A[2][0][0][2] = A[0][2][2][0] = A[2][0][2][0] = int(input('A_1313 = ') or '0')  # 4
    A[0][2][0][1] = A[2][0][1][0] = A[1][0][0][2] = A[2][0][0][1] = A[0][1][0][2] = A[0][1][2][0] = A[0][2][1][0] = \
    A[1][0][2][0] = int(input('A_1312 = ') or '0')  # 8
    A[0][1][0][1] = A[1][0][0][1] = A[0][1][1][0] = A[1][0][1][0] = int(input('A_1212 = ') or '0')  # 4
    return A

def matrix_cofactor(A):
    a = Symbol('a')
    B = np.repeat(a, 9).reshape([3, 3])
    B[0][0] = (A[1][1] * A[2][2]) - (A[2][1] * A[1][2])
    B[0][1] = - (A[1][0] * A[2][2]) + (A[2][0] * A[1][2])
    B[0][2] = (A[1][0] * A[2][1]) - (A[2][0] * A[1][1])
    B[1][0] = -(A[0][1] * A[2][2]) + (A[2][1] * A[0][2])
    B[1][1] = (A[0][0] * A[2][2]) - (A[2][0] * A[0][2])
    B[1][2] = - (A[0][0] * A[2][1]) + (A[2][0] * A[0][1])
    B[2][0] = (A[0][1] * A[1][2]) - (A[0][2] * A[1][1])
    B[2][1] = - (A[0][0] * A[1][2]) + (A[1][0] * A[0][2])
    B[2][2] = (A[0][0] * A[1][1]) - (A[1][0] * A[0][1])
    return B

def det(A):
    D = A[0][0] * ((A[1][1] * A[2][2]) - (A[2][1] * A[1][2])) - A[0][1] * ((A[1][0] * A[2][2]) - (A[2][0] * A[1][2])) + A[0][2] * ((A[1][0] * A[2][1]) - (A[2][0] * A[1][1]))
    return D

def tensorinv(A):
    A_9x9 = A.reshape([9, 9])
    A_inv = np.linalg.pinv(A_9x9)
    A_inv = A_inv.reshape([3, 3, 3, 3])
    return A_inv

def K_matrix(L, zeta):
    a = Symbol('a')
    K = np.repeat(a, 9).reshape([3, 3])
    for i in range(3):
        for j in range(3):
            K[i][j] = (L[i][j][0][0] * zeta[0] * zeta[0]) + (L[i][j][0][1] * zeta[0] * zeta[1]) + (
                        L[i][j][0][2] * zeta[0] * zeta[2]) + (L[i][j][1][0] * zeta[1] * zeta[0]) + \
                      (L[i][j][1][1] * zeta[1] * zeta[1]) + (L[i][j][2][0] * zeta[2] * zeta[0]) + (
                                  L[i][j][2][1] * zeta[2] * zeta[1]) + (L[i][j][2][2] * zeta[2] * zeta[2])
    return K

def H_Tensor(N, zeta):
    a = Symbol('a')
    H = np.repeat(a, 81).reshape([3, 3, 3, 3])
    for l in range(3):
        for k in range(3):
            for j in range(3):
                for i in range(3):
                    H[l][k][j][i] = (N[j][i] * zeta[j] * zeta[l]) + (N[k][j] * zeta[i] * zeta[l]) + (
                                N[l][i] * zeta[j] * zeta[k]) + (N[l][j] * zeta[i] * zeta[k])
    return H
